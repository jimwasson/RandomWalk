//
//  RandomWalk.swift
//  RandomMovement
//
//  Created by Jim Wasson on 3/7/16.
//  Copyright © 2016 Jim Wasson. All rights reserved.
//

import Foundation
import CoreLocation


// Protocol for RandomWalk clients.
// Provides the notification functions that clients need: 
//      - user location update and 
//      - new random locations as they are generated
//      - replay status (starting and stopping)
protocol RandomWalkDelegate : class {
    // Provides the current position of the user obtained from CLLocationManager.
    func userLocation(latitude:Double, longitude:Double)
    // Provides a new random location generated by RandomWalk.
    func randomLocation(id:Double, latitude:Double, longitude:Double)
    // Notifies delegates that we are starting or have finished a replay session.
    // At start (status = true) delegates. Ensure this is only sent once per session.
    // For replay finished or ended status = false.
    func notifyReplayStatus(status:Bool)
}

// Implemented as a singleton.
// Access the singleton from anywhere using RandomWalk.sharedInstance.
// We also subclass NSObject so we can use CLLocationManagerDelegate.
class RandomWalk: NSObject, CLLocationManagerDelegate {

    // Singleton class constant (requires Swift 1.2 or later).
    static let sharedInstance = RandomWalk()
    // Make init() private so it can't be used -- can only use as a singleton.
    private override init() {}

    // The RandomWalkDelegate variable. Set by the delegate.
    // Once set the RandomWalkDelegate functions will actually be called.
    var rwDelegate:RandomWalkDelegate?

    // Our local CoreLocation Manager instance.
    var locationManager = CLLocationManager()
    // Latitude and longitude deltas in degrees to give us a 100 mile region to display on the map.
    // For latitude, 1 degree is always 69 miles. So our latitude delta is 100.0 / 69.0 = 1.44928 degrees.
    // Longitude is also 69 miles per degree but it varies by latitude and is adjusted when we get a
    // position update.
    var latitudeDelta:CLLocationDegrees = 100.0 / 69.0
    var longitudeDelta:CLLocationDegrees = 100.0 / 69.0

    // The current user location reported by the CLLocationManager.
    // Just initialized to a default value.
    var userLocation:CLLocation = CLLocation()

    // The random location generation update time in seconds.
    // Default time is 1 hour = 3600.0 seconds.
    let updateTimeInterval:NSTimeInterval = 10.0
    // Location generation update timer.
    var locationUpdateTimer = NSTimer()

    // The replay display interval time in seconds.
    let replayTimeInterval:NSTimeInterval = 1.0
    // Replay update timer.
    var replayUpdateTimer = NSTimer()

    // The location radius in meters.
    let locationRadius = 160935.0 // Defaults to 160,935 meters = 100 miles.
    // Maximum distance to move from the last location in meters.
    let movementDeltaMax:CLLocationDistance = 3218.7 // 3218.7 meters = 2 miles.
    // Minimum distance to move from the last location in meters.
    let movementDeltaMin:CLLocationDistance = 1000.0  // Minimum distance to move of 1000 meters.
    // Maximum number of degrees to use when randomizing bearings to move along.
    let randomBearingAdjustment:Double = 45.0   // Bearing adjustment default plus or minus 45 degrees.

    // Array of random locations generated each hour.
    // We will store up to the last 48 random locations that were generated.
    // We initialize it with an empty dictionary entry so we don't need to use an optional.
    var randomLocations:[[String:Double]] = [[:]]
    // The maximum number of random locations to store.
    var randomLocationsMax = 48

    // MARK: External interface functions.

    // Initialization and startup. Needs to be called for the first startup.
    func startup() {
        // Initialize the CLLocation Manager instance.
        // Set ourselves as the CLLocationManagerDelegate.
        self.locationManager.delegate = self
        // Request authorization for location access when in use.
        self.locationManager.requestWhenInUseAuthorization()
        // Set the desired accuracy to be the best available.
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        // Starts the location manager updating our current location.
        self.locationManager.startUpdatingLocation()
        // Generate the first location.
        //self.generateRandomLocation()

        // Start updating.
        startUpdateTimer()
    }

    // Stop the current run, clear everything and start again.
    func restart() {
        // Stop the update timer.
        self.stopUpdateTimer()
        // Clear out all the saved locations.
        self.clearSavedLocations()
        // Generate the first location.
        self.generateRandomLocation()

        // Start updating.
        self.startUpdateTimer()
    }

    // Stop the current run, clear everything and replay from the saved locations.
    func replay() {
        // Stop the update timer.
        self.stopUpdateTimer()
        // Stop the replay timer (we might have been replaying.
        self.stopReplayTimer()
        // Notify the delegates.
        self.rwDelegate?.notifyReplayStatus(false)

        // Reset the replayIndex to -1
        self.replayIndex = -1
        // Clear the replayLocations array.
        self.replayLocations.removeAll()

        // Notify delegates replay is starting.
        self.rwDelegate?.notifyReplayStatus(true)

        // Start the replay timer.
        self.startReplayTimer()
    }

    // MARK: Timed update functions.

    // Starts the update timer. Repeats forever at the updateTimeInterval rate.
    // Calls generateRandomLocation().
    private func startUpdateTimer() {
        if self.locationUpdateTimer.valid == false {
            self.locationUpdateTimer = NSTimer.scheduledTimerWithTimeInterval(self.updateTimeInterval, target: self, selector: #selector(RandomWalk.generateRandomLocation), userInfo: nil, repeats: true)
        }
    }

    // Stops the update timer.
    // This needs to be done when the app goes into the background or or will exit.
    func stopUpdateTimer() {
        self.locationUpdateTimer.invalidate()
    }

    // Starts the replay update timer. Repeats forever at the updateTimeInterval rate.
    // Calls replaySavedLocations().
    private func startReplayTimer() {
        if self.replayUpdateTimer.valid == false {
            self.replayUpdateTimer = NSTimer.scheduledTimerWithTimeInterval(self.replayTimeInterval, target: self, selector: #selector(RandomWalk.replaySavedLocations), userInfo: nil, repeats: true)
        }
    }

    // Stops the replay update timer.
    // This needs to be done when the app goes into the background or or will exit.
    func stopReplayTimer() {
        self.replayUpdateTimer.invalidate()
    }

    // Generate a new random location and store it in the randomLocations array.
    // Uses movementDeltaMax to set the maximum distance to move from the last location.
    // Locations are saved with a datetime (NSDate) and the latitude and longitude.
    func generateRandomLocation() {
        if self.randomLocations[0] == [:] {
            // We initialized randomLocations to have an empty dictionary entry.
            // We don't have any locations yet so we need to generate the first one.
            // We generate a location < locationRadius miles but > 90% of locationRadius miles from the userLocation.
            let minDistance = locationRadius * 0.90 // Minimum will be 90% of the locationRadius setting.
            let distanceFromCurrent = Double(arc4random_uniform(UInt32(locationRadius - minDistance))) + minDistance
            // Generate random bearing to the new location.
            let bearingToLocation = Double(arc4random_uniform(360))
            // Generate the new location using distance and bearing from userLocation.
            let loc2D:CLLocationCoordinate2D = CLLocationCoordinate2DMake(self.userLocation.coordinate.latitude,
                self.userLocation.coordinate.longitude)
            let newLocation = self.newLocationBearing(bearingToLocation, distanceMeters: distanceFromCurrent, origin: loc2D)
            // Save the location.
            let entryNumber:Double = 1.0 // First entry id.
            // Create a new location dictionary.
            var locationEntry:[String:Double] = ["id":entryNumber]
            locationEntry["lat"] = newLocation.latitude
            locationEntry["lon"] = newLocation.longitude

            // Delete the empty first entry.
            self.randomLocations.removeFirst()

            // Add the new location to randomLocations. Just directly add as we know it's empty.
            self.randomLocations.append(locationEntry)

            // Notify RandomWalkDelegate protocol clients.
            self.rwDelegate?.randomLocation(entryNumber, latitude: newLocation.latitude, longitude: newLocation.longitude)
        } else {
            // Generate a random distance to move from movementDeltaMin to movementDeltaMax.
            var distanceToMove = Double(arc4random_uniform(UInt32(self.movementDeltaMax)))
            if distanceToMove < self.movementDeltaMin {
                distanceToMove += self.movementDeltaMin
            }
            // Get the last location. This should be the latest location.
            // Sort the locations array to get the latest one at the top.
            let sortedLocations:[[String:Double]] = self.randomLocations.sort() { $0["id"] < $1["id"] }
            // Convert the saved last location to a CLLocationCoordinate2D
            if let lastLocation = sortedLocations.last, lastId:Double = lastLocation["id"], lat:Double = lastLocation["lat"], lon:Double = lastLocation["lon"] {
                let lastCLLocation = CLLocationCoordinate2DMake(CLLocationDegrees(lat), CLLocationDegrees(lon))
                // If we are less than movementDeltaMax away from the userLocation, we stop.
                if self.distanceBetweenPoints(lastCLLocation, point2: self.userLocation.coordinate) < self.movementDeltaMax {
                    // Stop the update timer.
                    self.stopUpdateTimer()
                    // Save our random locations array.
                    self.saveLocations()
                    
                    return
                }

                // Generate a bearing from lastLocation towards the userLocation.
                let newBearing = self.bearingToLocation(lastCLLocation, toLocation: self.userLocation)
                // Randomize the bearing.
                let randomBearing = self.randomizeBearing(newBearing)
                let newLocation = self.newLocationBearing(randomBearing, distanceMeters: distanceToMove, origin: lastCLLocation)
                // Save the location.
                let newId = Double(lastId) + 1.0

                // Create a new location dictionary.
                var locationEntry:[String:Double] = ["id":newId]
                locationEntry["lat"] = newLocation.latitude
                locationEntry["lon"] = newLocation.longitude
                // Add the new location to randomLocations. addNewLocation() accounts for the maximum length.
                self.addNewLocation(locationEntry, lastLocation: lastLocation)

                // Notify RandomWalkDelegate protocol clients.
                self.rwDelegate?.randomLocation(newId, latitude: newLocation.latitude, longitude: newLocation.longitude)
            }
        }
    }

    // MARK: Replay saved locations.

    // Cache the sorted locations so we can replay them efficiently.
    var replayLocations:[[String:Double]] = [[:]]
    // Index into replayLocations for the location just replayed.
    // A value of -1 means we are just starting.
    var replayIndex = -1
    // Replay the locations from the earliest to the latest.
    func replaySavedLocations() {
        // Make sure we have saved locations to be replayed.
        guard let loc = self.randomLocations.first where loc != [:] else {
            // Stop the replay timer.
            self.stopReplayTimer()
            // Notify the delegates.
            self.rwDelegate?.notifyReplayStatus(false)

            return
        }
        if replayIndex == -1 {
            // Just starting the session.
            // Sort the locations array to get the latest one at the top.
            replayLocations = self.randomLocations.sort() { $0["id"] < $1["id"] }
            replayIndex = 0 // Set the replay index to the first element.
        }
        if self.replayLocations.count > self.replayIndex {
            let location = self.replayLocations[self.replayIndex]
            if let id = location["id"], latitude = location["lat"], longitude = location["lon"] {
                // Notify RandomWalkDelegate protocol clients.
                self.rwDelegate?.randomLocation(id, latitude: latitude, longitude: longitude)
            }
            // Set index for the next entry.
            self.replayIndex += 1
        } else {
            // Last one was replayed.
            self.stopReplayTimer()
            // Notify the delegates.
            self.rwDelegate?.notifyReplayStatus(false)
            // Reset the replayIndex to -1
            self.replayIndex = -1
            // Clear the replayLocations array.
            self.replayLocations.removeAll()
        }
    }

    // MARK: Location Management functions.

    // Add the new location to the randomLocations array.
    // Treat it as a circular queue, respecting the limit of 48 entries.
    private func addNewLocation(newLocation:[String:Double], lastLocation:[String:Double]) {
        // If the array isn't full, just append newLocation to it.
        if self.randomLocations.count < randomLocationsMax {
            self.randomLocations.append(newLocation)
        } else {
            // Find the lowest ID number element to replace.
            var lowestId = DBL_MAX //1000000000.0
            var lowestIndex = 0
            for ndx in 0..<self.randomLocations.count {
                if let id = self.randomLocations[ndx]["id"] {
                    if id < lowestId {
                        lowestId = id
                        lowestIndex = ndx
                    }
                }
            }
            // Replace the lowestIndex element.
            self.randomLocations[lowestIndex] = newLocation
            print("replacing index \(lowestIndex)")
        }
    }

    // Calculate the bearing between two points.
    // Meant to give the bearing from point1 (the last random location) to point2 (the userLocation).
    private func bearingToLocation(fromLocation : CLLocationCoordinate2D, toLocation : CLLocation) -> Double {
        // Returns a float with the angle in degrees between the two points.

        let lat1 = fromLocation.latitude * (M_PI / 180.0) // Convert latitude to radians.
        let lat2 = toLocation.coordinate.latitude * (M_PI / 180.0) // Convert latitude to radians.
        let deltaLon = (toLocation.coordinate.longitude - fromLocation.longitude) * (M_PI / 180.0) // Convert difference to radians.
        let y = sin(deltaLon) * cos(lat2)
        let x = cos(lat1) * sin(lat2) - (sin(lat1) * cos(lat2) * cos(deltaLon))
        let brng = atan2(y, x)

        return ((brng * (180.0 / M_PI)) + 360) % 360 // Return bearing in degrees.
    }

    // Randomize a bearing by plus or minus the randomBearingAdjustment (in degrees).
    private func randomizeBearing(bearing:Double) -> Double {
        // Generate randomized adjustment value
        let adjustment:Double = Double(arc4random_uniform(UInt32(self.randomBearingAdjustment)))
        // Decide on adding the adjustment (1) or subtracting (0).
        let plusOrMinus = arc4random_uniform(2)
        // Calculate the adjusted bearing.
        let adjustedBearing = plusOrMinus == 0 ? bearing - adjustment : bearing + adjustment

        return adjustedBearing
    }

    // Calculate the location that is bearing and distanceMeters from the given location.
    private func newLocationBearing(bearing:Double, distanceMeters:Double, origin:CLLocationCoordinate2D) -> CLLocationCoordinate2D {
        let distRadians = distanceMeters / (6372797.6) // earth radius in meters

        // Convert degrees to radians.
        let lat1 = origin.latitude * (M_PI / 180.0)
        let lon1 = origin.longitude * (M_PI / 180.0)
        let brngRadians = bearing * (M_PI / 180.0)

        let lat2 = asin(sin(lat1) * cos(distRadians) + cos(lat1) * sin(distRadians) * cos(brngRadians))
        let x = cos(distRadians) - (sin(lat1) * sin(lat2))
        let y = sin(brngRadians) * sin(distRadians) * cos(lat1)
        let lon2 = lon1 + atan2(y, x)

        return CLLocationCoordinate2D(latitude: lat2 * 180 / M_PI, longitude: ((lon2 * 180 / M_PI) + 540.0) % 360 - 180)
    }

    // Distance between two positions using law of cosines (good for short distances).
    // d = acos( sin φ1 ⋅ sin φ2 + cos φ1 ⋅ cos φ2 ⋅ cos Δλ ) ⋅ R
    private func distanceBetweenPoints(point1:CLLocationCoordinate2D, point2:CLLocationCoordinate2D) -> Double {
        var distance:Double = 0.0
        let lat1R = point1.latitude * (M_PI / 180.0)
        let lon1R = point1.longitude * (M_PI / 180.0)
        let lat2R = point2.latitude * (M_PI / 180.0)
        let lon2R = point2.longitude * (M_PI / 180.0)
        distance = acos((sin(lat1R) * sin(lat2R)) + (cos(lat1R) * cos(lat2R)) * cos(lon2R - lon1R)) * (6372797.6)
        print(distance)
        return distance
    }

    // Save the entire udpated randomLocations array in NSUserDefaults.
    private func saveLocations() {
        NSUserDefaults.standardUserDefaults().setObject(randomLocations, forKey: "randomLocations")
        // In iOS 8+ we shouldn't call synchronize() unless absolutely necessary.
        // NSUserDefaults.standardUserDefaults().synchronize() // Force save.
    }

    // Get the randomLocations saved in NSUserDefaults and update the randomLocations array.
    private func getLocations() {
        // Make sure we have a stored array in NSUserDefaults to retrieve.
        guard NSUserDefaults.standardUserDefaults().arrayForKey("randomLocations") != nil else {
            return
        }
        self.randomLocations = (NSUserDefaults.standardUserDefaults().arrayForKey("randomLocations") as? [[String:Double]])!
    }

    // Clear all saved location data.
    private func clearSavedLocations() {
        // Clear out the randomLocations array.
        self.randomLocations.removeAll(keepCapacity: true)
        self.randomLocations.append([:])    // Initialize as "empty" with a single empty array.
        // Push the now empty randomLocations array to NSUserDefaults.
        self.saveLocations()
    }

    // MARK: CLLocation Manager Delegate functions.

    // Called for a location update.
    // Update the current location and show it on the map but only one time.
    func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        // Stop further updates. We only need our current position.
        manager.stopUpdatingLocation()

        self.userLocation = locations[0]

        print("user location: \(self.userLocation)")
        // Adjust the longitudeDelta for our new latitude value.
        var posLat = self.userLocation.coordinate.latitude
        if posLat < 0.0 {
            // Latitude is West so it's negative. We just need positive values for our calculations.
            posLat *= -1.0
        }
        // Calculate the new longitude delta using our current latitude and save it.
        let longDelta: CLLocationDegrees = (100.0 / (69.0 - ((90.0 / 69.0) * posLat)))
        self.longitudeDelta = longDelta

        // Notify RandomWalkDelegate protocol clients of the new userLocation.
        rwDelegate?.userLocation(self.userLocation.coordinate.latitude, longitude: self.userLocation.coordinate.longitude)
    }

    // Called if a location error occurs.
    func locationManager(manager:CLLocationManager, didFailWithError error:NSError) {
        print("Location Manager Error: \(error)")
    }
}